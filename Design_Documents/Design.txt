Tong Mobile Language Learning Application â€“Â Comprehensive Technical, Workflow & Curriculum Design
Taskâ€‘byâ€‘Task Master Spec â€¢ v3.0.2 (Mayâ€¯19â€¯2025) â€“ Focused Build Specification
0. Executive Overview
Tong is a fullyâ€‘featured, mobileâ€‘first languageâ€‘learning ecosystem meticulously engineered to foster genuine communicative competence. It's built around five concentric, mutually reinforcing motivational and pedagogical loops:
(1) Microâ€‘lesson Mastery:Â Bite-sized, interactive lessons focusing on specific vocabulary, grammar points, or communicative functions, designed for quick wins and building foundational knowledge. Each lesson is a self-contained unit, ensuring focused learning without cognitive overload.
(2) Errorâ€‘driven Review:Â An intelligent review system, powered by a sophisticated Spaced Repetition System (SRS) and analysis of learner errors. This loop ensures that challenging material is revisited optimally, converting weaknesses into strengths. It's not just about repetition, butÂ targetedÂ repetition.
(3) Periodic Boss Assessment:Â Comprehensive, milestone-based assessments at the end of each learning "band." These "Boss Battles" test cumulative knowledge and application in a simulated, slightly higher-stakes environment, providing a clear sense of progression and achievement.
(4) Social Competition:Â Gamified elements, including Elo-rated asynchronousÂ audio-onlyÂ speaking duels (Quick Games) and leaderboards, designed to harness the power of friendly competition and social accountability to drive engagement and consistent practice.
(5) Realâ€‘time Human Interaction (Teacher-Led):Â The pinnacle of the learning experience, offeringÂ paid 1-on-1 live WebRTC video sessionsÂ with vetted teachers for personalized coaching and direct conversational practice.
The pedagogical spine of Tong is theÂ ACTFL proficiency scaleÂ (Novice Low â†’ Intermediate Mid â†’ Advanced High â†’ Superior). Content and assessments are carefully mapped to these proficiency bands, ensuring a structured and measurable journey towards fluency.
Cutting-edgeÂ AI services (specifically Whisper V3 for highly accurate transcription and DeepSeek V3 for nuanced language analysis and feedback)Â are deeply integrated to automate and scale spokenâ€‘language feedback, providing learners with insights traditionally only available through direct tutor interaction. The backend infrastructure leveragesÂ Supabase, an opinionated, serverless BaaS (Backend-as-a-Service) platform, for its robust PostgreSQL database, authentication, real-time capabilities, edge functions, and storage, significantly reducing backend development overhead. To maximize development velocity and ensure consistency, all application code (iOS native and Deno-based Edge Functions) resides in aÂ single monoâ€‘repository, streamlining Continuous Integration and Continuous Deployment (CI/CD) pipelines.
Key Product Pillars & Differentiators:
Selfâ€‘study Path (The Foundation):
Learn:Â Structured lessons introducing new concepts within the current ACTFL band.
Review:Â Personalized flashcard drills and error correction exercises based on SRS and past performance.
Boss:Â Challenging assessments to confirm mastery of a band before progressing.
Band-scoped Flashcards:Â All flashcards are contextualized within the current learning band, ensuring relevance.
No Heart/Life Gating:Â Progress is driven by mastery and effort, not artificial timers or consumable "lives," promoting sustained engagement.
Asynchronous Voice Games (Peer-to-Peer Audio Duels):
Turnâ€‘based Speaking Duels (Audio-Only):Â Users engage in "Quick Talk" games, exchanging short voice messages on given prompts with other learners.
Eloâ€‘rated:Â A skill-based rating system ensures fair matchmaking and tracks speaking proficiency progression.
Bootstraps Social Motivation:Â The desire to improve one's Elo rating and compete on leaderboards encourages frequent speaking practice.
Live Teacher Sessions (Personalized Expert Video Guidance):
Paid 1â€‘onâ€‘1 WebRTC Video Calls:Â Secure, high-quality video calls with qualified language teachers.
Postâ€‘lesson AI Transcripts & Analysis:Â Students receive detailed, AI-generated reports on their performance during the session, including transcripts, error correction, and fluency metrics.
Gamification & Monetisation (Engagement & Sustainability):
Core Mechanics:Â Experience Points (XP), daily streaks, leveling system, Elo ratings, and competitive leaderboards.
Tong Pro Subscription:Â A premium offering that unlocks unlimited AI usage (voice note analysis, game turn analysis, session reports), priority queues for support or certain features, and potentially exclusive content or early access.
Operational Excellence (Reliability & Scalability):
Automated Tests:Â Comprehensive unit, integration, and UI tests to ensure code quality and prevent regressions.
Observability Dashboards:Â Real-time monitoring of key system metrics, application performance, and API usage.
Cost Guardrails:Â Proactive measures and alerts to manage cloud service expenditures (AI APIs, WebRTC infrastructure, Supabase).
Progressive Featureâ€‘Flag Framework:Â Enables controlled rollouts of new features, A/B testing, and rapid rollback capabilities.
1. Repository & Environment
1.1 Create Monoâ€‘Repo (tongâ€‘app)
The decision for a mono-repository is driven by the desire for simplified dependency management, atomic cross-project commits (e.g., an API change inÂ functions/Â and its corresponding client update inÂ ios/Â can be part of the same PR and commit), and streamlined CI/CD setup.
Directory StandardÂ â€“ A clear, conventional structure is crucial for maintainability:
ios/: Contains the entire Xcode project for the native iOS application.
Tong.xcodeproj: The main Xcode project file.
Sources/: Swift source code, organized by feature or architectural layer (e.g.,Â Services/,Â Views/,Â ViewModels/,Â Models/,Â Utils/).
Resources/: Assets like images, localization files, etc.
Packages/: Swift Package Manager dependencies will be managed here.
Configurations/: SeparateÂ Info.plistÂ files (e.g.,Â Info-Debug.plist,Â Info-Release.plist,Â Info-TestFlight.plist) for different build configurations, allowing distinct bundle identifiers, API keys (referenced via build settings), or feature flags per environment.
functions/: Houses all serverless Supabase Edge Functions, written in Deno (TypeScript).
Organization by feature domain (e.g.,Â ai/processPracticeAudio.ts,Â payments/stripeWebhook.ts,Â games/submitTurn.ts,Â scheduler/rebuildLeaderboards.ts) makes navigation and ownership clear. Each function typically resides in its own file or a subdirectory if it has associated helper modules.
.github/workflows/: YAML files defining GitHub Actions for CI/CD.
ios-ci.yml: Handles building, testing, and potentially archiving the iOS app.
deno-ci.yml: Handles linting, testing, and deploying Deno Edge Functions.
supabase-ci.yml: Handles Supabase schema migrations and database tests.
Commit HooksÂ â€“ Automated checks before commits are accepted, enforced using tools like Husky:
Preâ€‘commit Linting:
SwiftFormat: Automatically formats Swift code according to defined style rules, ensuring consistency.
deno fmt: Automatically formats Deno TypeScript/JavaScript code.
Secretâ€‘Scanner:Â Tools likeÂ gitleaksÂ orÂ trufflehogÂ scan staged files for accidentally committed secrets (API keys, passwords), preventing them from entering the repository history.
1.2 Supabase Project Bootstrap
Leveraging Supabase CLI for local development and linking to a cloud-hosted project.
Initialise Project:Â supabase initÂ creates the local Supabase environment configuration.Â supabase loginÂ andÂ supabase link --project-ref <your-project-id>Â connect the local setup to the remote Supabase project.
Region Selection:Â usâ€‘eastâ€‘1Â (N. Virginia) is chosen for the Supabase project. This decision is based on the anticipated geographical concentration of initial beta testers and aims to minimize latency for core database operations and Edge Function invocations for this user group. This can be revisited as the user base grows and diversifies.
Realtime Configuration:Â Supabase Realtime is enabled by default for the project, allowing WebSocket connections for instant data synchronization and push notifications for features like asynchronous game turn updates and live teacher call signaling. Replication for specific tables will be configured as needed.
Row Security (RLS):Â Enabled by default at the project level. This mandates that all table access must be explicitly granted via RLS policies, adopting a "secure by default" posture.
Local Dev DB Images:Â For hermetic (isolated and reproducible) testing, especially for CI, local Supabase development instances (supabase start) can be used. Snapshots or migration rollbacks (supabase db reset) allow tests to run against a known database state.
1.3 CI Pipeline (GitHub Actions)
Automated workflows triggered on pushes or pull requests toÂ mainÂ and feature branches.
iOS Job (ios-ci.yml):
Runs on aÂ macOS-latestÂ runner.
xcode-selectÂ might be needed to specify the Xcode version if multiple are available on the runner.
Caching:Â CocoaPods (~/.cocoapods) and Swift Package Manager build artifacts (.build/) are cached between runs to speed up build times.
Testing:Â xcodebuild -workspace Tong.xcworkspace -scheme Tong -destination 'platform=iOS Simulator,name=iPhone 15' -enableCodeCoverage YES test | xcprettyÂ executes unit and UI tests.Â xcprettyformats the output for better readability. Code coverage reports can be generated and uploaded.
Deno Job (deno-ci.yml):
Runs on anÂ ubuntu-latestÂ runner.
Linting & Formatting Check:Â deno lintÂ andÂ deno fmt --checkÂ ensure code quality and style adherence.
Testing:Â deno test --allow-net --allow-env --coverage=cov_profileÂ runs tests for Edge Functions.Â --allow-netandÂ --allow-envÂ grant necessary permissions for tests that might make external calls or read environment variables (e.g., mock API keys). Coverage reports can be generated (deno coverage cov_profile).
Supabase Job (supabase-ci.yml):
Runs on anÂ ubuntu-latestÂ runner.
Ephemeral Postgres:Â A temporary local Postgres instance is spun up using Docker, often viaÂ supabase start.
Schema Migrations:Â supabase db pushÂ (or applying migrations sequentially fromÂ supabase/migrations/) ensures the schema is up-to-date.
SQL Unit Tests:Â pgTapÂ (a SQL testing framework) tests are executed against the ephemeral database to validate RLS policies, functions, triggers, and complex queries directly within Postgres. This might involve running a script likeÂ psql -U postgres -d postgres -f tests/sql/run_tests.sql.
1.4 Secrets Management
Robust handling of sensitive information is paramount.
.env.example:Â A template file committed to the repository. It listsÂ allÂ environment variables required by the iOS app and Edge Functions (e.g.,Â SUPABASE_URL=__MISSING__,Â SUPABASE_ANON_KEY=__MISSING__,Â WHISPER_API_KEY=__MISSING__,Â STRIPE_PUBLISHABLE_KEY=__MISSING__). Developers copy this toÂ .envÂ and fill in their local development values.Â .envÂ itself is gitignored.
GitHub Secrets:Â Production and staging values for API keys, database passwords, etc., are stored as encrypted secrets at the GitHub repository or organization level.
Actions Injection:Â GitHub Actions workflows securely inject these secrets as environment variables into the CI runner environments. These are masked in logs by default.
CI Failure on Missing Keys:Â A script within the CI jobs checks if any required environment variable (as defined perhaps by checking againstÂ .env.exampleÂ or a predefined list) still holds theÂ __MISSING__Â placeholder or is unset. If so, the build fails, preventing deployments with incomplete configurations.
2. Database & Security (Postgres + RLS)
The Supabase-managed PostgreSQL database is the single source of truth. RLS is the primary mechanism for data access control.
2.1 Schema Migration â€“Â Detailed Table Spec
Migrations are managed usingÂ supabase/migrations/<timestamp>_migration_name.sqlÂ files.
profilesÂ (Stores user-specific data beyondÂ auth.users)
user_id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE: Foreign key to Supabase's built-inÂ auth.usersÂ table.Â ON DELETE CASCADEÂ ensures profile data is removed if the auth user is deleted.
display_name TEXT CHECK (char_length(display_name) >= 3 AND char_length(display_name) <= 50): User's chosen public name.
avatar_url TEXT: URL to the user's avatar image (potentially stored in Supabase Storage).
xp BIGINT DEFAULT 0 CHECK (xp >= 0): Total experience points earned.
level INT DEFAULT 1 CHECK (level >= 1): Current user level, derived from XP.
streak INT DEFAULT 0 CHECK (streak >= 0): Current daily engagement streak.
elo INT DEFAULT 1200 CHECK (elo >= 0): Elo rating for Quick Games. Initialized at a common starting value.
pro_subscription BOOLEAN DEFAULT FALSE: Flag indicating if the user has an active Tong Pro subscription.
pro_subscription_expires_at TIMESTAMPTZ: Timestamp for when the pro subscription ends, if applicable.
created_at TIMESTAMPTZ DEFAULT now(): Timestamp of profile creation.
updated_at TIMESTAMPTZ: Timestamp of last profile update (automatically updated by a trigger).
Indexes:Â CREATE INDEX idx_profiles_elo ON profiles(elo);Â for leaderboard and matchmaking.
languagesÂ (Languages offered for learning)
language_id SERIAL PRIMARY KEY: Auto-incrementing integer ID.
code CHAR(2) UNIQUE NOT NULL: ISO 639-1 language code (e.g.,Â en,Â es,Â fr).
name TEXT UNIQUE NOT NULL: Full language name (e.g., "English", "Spanish", "French").
flag_emoji TEXT: Emoji representing the language flag (e.g., "ðŸ‡¬ðŸ‡§", "ðŸ‡ªðŸ‡¸", "ðŸ‡«ðŸ‡·").
bandsÂ (Proficiency levels within each language, e.g., Novice-Low, Novice-Mid)
band_id SERIAL PRIMARY KEY: Auto-incrementing integer ID.
language_id INT NOT NULL REFERENCES languages(language_id) ON DELETE CASCADE: Links to the language this band belongs to.
short_label TEXT NOT NULL: Concise label (e.g., "N1", "I2", "A3").
long_label TEXT NOT NULL: Descriptive label (e.g., "Novice Low", "Intermediate Mid", "Advanced High"). Aligns with ACTFL or CEFR.
order_idx INT NOT NULL: Defines the progression order of bands within a language.
units_required INT NOT NULL CHECK (units_required > 0): Number of core units a user must complete to be eligible for this band's Boss Battle.
Indexes:Â CREATE UNIQUE INDEX idx_bands_language_order ON bands(language_id, order_idx);
user_band_progressÂ (Tracks user progress through each band of a language)
user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE: Foreign key to the user.
band_id INT NOT NULL REFERENCES bands(band_id) ON DELETE CASCADE: Foreign key to the band.
units_completed INT DEFAULT 0 CHECK (units_completed >= 0): Number of units completed by the user in this band.
boss_passed BOOLEAN DEFAULT FALSE: Flag indicating if the user has passed the Boss Battle for this band.
started_at TIMESTAMPTZ DEFAULT now(): When the user first started this band (e.g., completed first unit or explicitly started).
passed_at TIMESTAMPTZ: Timestamp when the user passed the Boss Battle for this band.
PRIMARY KEYÂ (user_id, band_id)
unitsÂ /Â lessonsÂ /Â cardsÂ (Hierarchical content structure)
unitsÂ (Thematic collections of lessons within a band)
unit_id SERIAL PRIMARY KEY
band_id INT NOT NULL REFERENCES bands(band_id) ON DELETE CASCADE
title TEXT NOT NULL
description TEXT
order_idx INT NOT NULL
Indexes:Â CREATE UNIQUE INDEX idx_units_band_order ON units(band_id, order_idx);
lessonsÂ (Specific learning objectives within a unit)
lesson_id SERIAL PRIMARY KEY
unit_id INT NOT NULL REFERENCES units(unit_id) ON DELETE CASCADE
title TEXT NOT NULL
lesson_type TEXT NOT NULLÂ (e.g., 'vocabulary', 'grammar', 'comprehension', 'pronunciation_focus')
content_json JSONB: Flexible field for lesson content, could be Markdown, interactive exercise definitions, etc.
xp_value INT DEFAULT 15 CHECK (xp_value >=0): XP awarded for completing this lesson.
order_idx INT NOT NULL
Indexes:Â CREATE UNIQUE INDEX idx_lessons_unit_order ON lessons(unit_id, order_idx);
cardsÂ (Individual flashcards, typically linked to lessons)
card_id SERIAL PRIMARY KEY
lesson_id INT REFERENCES lessons(lesson_id) ON DELETE SET NULL: Card can optionally be linked to a specific lesson. If a lesson is deleted, the card remains but is unlinked.
language_id INT NOT NULL REFERENCES languages(language_id): Target language of the card.
target_text TEXT NOT NULL: Word or phrase in the target language.
native_text TEXT NOT NULL: Translation in the user's native language (or a common reference language like English).
audio_url TEXT: URL to an audio pronunciation ofÂ target_textÂ (Supabase Storage).
image_url TEXT: URL to an illustrative image (Supabase Storage).
answer_json JSONB: Stores correct answers and acceptable alternatives. Example:Â {"type": "translation", "correct": ["hello"], "alternatives": ["hi", "hey"]}Â orÂ {"type": "multiple_choice", "options": ["A", "B", "C"], "correct": "A"}. This structure provides flexibility for different question types and spelling/phrasing variations.
difficulty_rating INT DEFAULT 3 CHECK (difficulty_rating BETWEEN 1 AND 5): Admin-set initial difficulty (1-easy, 5-hard).
card_reviewsÂ (User-specific Spaced Repetition System (SRS) data for each card)
user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE
card_id INT NOT NULL REFERENCES cards(card_id) ON DELETE CASCADE
interval INT DEFAULT 0: Current SRS interval in days.
ease_factor FLOAT DEFAULT 2.5: SM-2 ease factor, influencing interval growth.
repetitions INT DEFAULT 0: Number of times the card has been successfully recalled.
next_review_at DATE NOT NULL: Date when this card is due for review.
last_reviewed_at TIMESTAMPTZ: Timestamp of the last review.
PRIMARY KEYÂ (user_id, card_id)
Indexes:Â CREATE INDEX idx_card_reviews_next_review ON card_reviews(user_id, next_review_at);Â for efficient querying of due cards.
learn_errorsÂ (Tracks user mistakes during learning activities for targeted review)
user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE
card_id INT NOT NULL REFERENCES cards(card_id) ON DELETE CASCADE
error_count INT DEFAULT 1 CHECK (error_count > 0): Frequency of incorrect answers for this card.
last_error_at TIMESTAMPTZ DEFAULT now(): Timestamp of the most recent error.
error_details JSONB: Optional field to store specifics about the error (e.g., what wrong answer was given).
PRIMARY KEYÂ (user_id, card_id)
boss_testsÂ (Definitions for end-of-band assessments)
boss_test_id SERIAL PRIMARY KEY
band_id INT UNIQUE NOT NULL REFERENCES bands(band_id) ON DELETE CASCADE: Each band has one unique boss test.
title TEXT NOT NULL
items_json JSONB NOT NULL: An ordered array defining the questions. Each item specifies type (e.g., 'multiple_choice_text', 'translate_text_to_audio', 'listen_and_type', 'speak_phrase'), content (question text, audio URL, image URL, options), and correct answer(s).
time_limit_seconds INT CHECK (time_limit_seconds > 0): Duration allowed for the test.
pass_score_pct INT NOT NULL CHECK (pass_score_pct > 0 AND pass_score_pct <= 100): Minimum percentage score to pass.
Game & Live Ops Tables:
quick_gamesÂ (Asynchronous Audio-Only Games):
game_id UUID PRIMARY KEY DEFAULT gen_random_uuid()
language_id INT NOT NULL REFERENCES languages(language_id)
player1_id UUID NOT NULL REFERENCES auth.users(id)
player2_id UUID REFERENCES auth.users(id)Â (NULL if waiting for opponent or vs AI)
current_turn_player_id UUID REFERENCES auth.users(id)
status TEXT NOT NULL DEFAULT 'pending_player2'Â (e.g.,Â pending_player2,Â player1_turn,Â player2_turn,Â completed,Â expired)
winner_id UUID REFERENCES auth.users(id)
elo_change_p1 INT,Â elo_change_p2 INT
created_at TIMESTAMPTZ DEFAULT now()
last_turn_at TIMESTAMPTZ
expires_at TIMESTAMPTZ: Timestamp for when a turn or game might expire.
Indexes:Â CREATE INDEX idx_quick_games_status_lang ON quick_games(status, language_id);Â for matchmaking.
quick_game_turnsÂ (Turns for Asynchronous Audio-Only Games):
turn_id UUID PRIMARY KEY DEFAULT gen_random_uuid()
game_id UUID NOT NULL REFERENCES quick_games(game_id) ON DELETE CASCADE
player_id UUID NOT NULL REFERENCES auth.users(id)
turn_number INT NOT NULL
prompt_text TEXTÂ (optional prompt for the turn)
audio_url TEXT NOT NULLÂ (Supabase Storage link to the voice note)
transcript TEXT
ai_analysis JSONBÂ (Stores feedback like WPM, unique words, filler words from DeepSeek)
submitted_at TIMESTAMPTZ DEFAULT now()
practice_reportsÂ (For self-study voice note analysis):
report_id UUID PRIMARY KEY DEFAULT gen_random_uuid()
user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE
language_id INT NOT NULL REFERENCES languages(language_id)
audio_url TEXT NOT NULL
transcript TEXT
feedback JSONBÂ (Detailed feedback from DeepSeek: WPM, mispronunciations array, fluency score, grammar tips)
created_at TIMESTAMPTZ DEFAULT now()
teacher_slotsÂ (Teacher availability for Video Lessons):
slot_id UUID PRIMARY KEY DEFAULT gen_random_uuid()
teacher_id UUID NOT NULL REFERENCES auth.users(id)Â (Assuming teachers are also users with a specific role)
start_time TIMESTAMPTZ NOT NULL
end_time TIMESTAMPTZ NOT NULL
status TEXT DEFAULT 'available'Â (e.g.,Â available,Â booked,Â tentative_booking)
booking_id UUID REFERENCES bookings(booking_id) ON DELETE SET NULL
price_usd DECIMAL(10,2)Â (If price varies per slot/teacher)
CHECK (end_time > start_time)
Indexes:Â CREATE INDEX idx_teacher_slots_teacher_start ON teacher_slots(teacher_id, start_time);
bookingsÂ (Student bookings for Teacher Video Lessons):
booking_id UUID PRIMARY KEY DEFAULT gen_random_uuid()
student_id UUID NOT NULL REFERENCES auth.users(id)
teacher_id UUID NOT NULL REFERENCES auth.users(id)
slot_id UUID UNIQUE NOT NULL REFERENCES teacher_slots(slot_id)
session_start_time TIMESTAMPTZ NOT NULL
session_end_time TIMESTAMPTZ NOT NULL
status TEXT NOT NULLÂ (e.g.,Â pending_payment,Â confirmed,Â completed,Â cancelled_student,Â cancelled_teacher)
stripe_payment_intent_id TEXT
created_at TIMESTAMPTZ DEFAULT now()
session_analysisÂ (Post-Live Teacher Video Lesson reports):
analysis_id UUID PRIMARY KEY DEFAULT gen_random_uuid()
booking_id UUID NOT NULL REFERENCES bookings(booking_id) ON DELETE CASCADE
student_id UUID NOT NULL REFERENCES auth.users(id)
teacher_id UUID NOT NULL REFERENCES auth.users(id)
diarized_transcript_url TEXTÂ (Link to full session transcript, possibly with speaker labels)
student_feedback JSONBÂ (DeepSeek analysis of student's speech: fluency, complexity, accuracy scores, specific examples)
teacher_notes TEXTÂ (Optional notes from the teacher)
created_at TIMESTAMPTZ DEFAULT now()
leaderboard_cacheÂ (Pre-calculated leaderboard data for fast reads):
leaderboard_type TEXT NOT NULLÂ (e.g.,Â weekly_xp,Â all_time_xp,Â language_elo_es)
rank INT NOT NULL
user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE
score BIGINT NOT NULLÂ (XP or Elo score)
updated_at TIMESTAMPTZ DEFAULT now()
PRIMARY KEYÂ (leaderboard_type, rank)
Indexes:Â CREATE INDEX idx_leaderboard_user ON leaderboard_cache(leaderboard_type, user_id);
remote_configÂ (For feature flags and dynamic app configuration)
key TEXT PRIMARY KEY: Unique key for the config item (e.g.,Â enableNewFeatureX,Â paywallPriceTierA).
value JSONB NOT NULL: The configuration value (can be boolean, string, number, object, array).
description TEXT: Human-readable description of the config item.
updated_at TIMESTAMPTZ DEFAULT now(): When this config was last updated.
2.2 Rowâ€‘Level Security (RLS) Policies
RLS policies are SQL conditions that are implicitly ANDed to any query.Â auth.uid()Â returns the ID of the currently authenticated user.
Default Deny (Implicit):Â Supabase starts with no access; policies grant specific permissions.
User-Owned Data (e.g.,Â profiles,Â card_reviews,Â user_band_progress,Â learn_errors,Â practice_reports):
CREATE POLICY "Users can manage their own data." ON <table> FOR ALL USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);
This common pattern allows users to perform any operation (SELECT, INSERT, UPDATE, DELETE) only on rows where theirÂ user_idÂ matches.Â WITH CHECKÂ applies to INSERT/UPDATE.
Readâ€‘Only Global Tables (languages,Â bands,Â units,Â lessons,Â cards,Â boss_tests,Â remote_config):
CREATE POLICY "Public read access for global content." ON <table> FOR SELECT USING (true);
These tables contain general application content or configuration and should be readable by any authenticated user. No INSERT, UPDATE, or DELETE is allowed for regular users. Content management would be done via admin tools or specific Edge Functions using a service role.
Conditional Multiâ€‘User Access (quick_games,Â quick_game_turns):
ForÂ quick_games:
CREATE POLICY "Players can view and update their own games." ON quick_games FOR ALL USING (auth.uid() = player1_id OR auth.uid() = player2_id) WITH CHECK (auth.uid() = current_turn_player_id OR (status = 'pending_player2' AND auth.uid() = player1_id));Â (This is a simplified example; actual policies might be more granular for SELECT, UPDATE based on game state).
ForÂ quick_game_turns:
CREATE POLICY "Players can view turns in their games and insert their own." ON quick_game_turns FOR SELECT USING (game_id IN (SELECT game_id FROM quick_games WHERE auth.uid() = player1_id OR auth.uid() = player2_id));
CREATE POLICY "Players can insert their own turns." ON quick_game_turns FOR INSERT WITH CHECK (auth.uid() = player_id AND game_id IN (SELECT game_id FROM quick_games WHERE auth.uid() = current_turn_player_id));
Teacher-Specific Access (teacher_slots,Â bookingsÂ where teacher is involved):
Teachers might have policies to manage theirÂ teacher_slotsÂ (auth.uid() = teacher_id).
Both student and teacher can view their sharedÂ bookings.
Service Role Bypass:Â Edge Functions using theÂ service_role_keyÂ (stored securely as an environment variable) bypass RLS entirely. This is necessary for operations like:
TheÂ scheduler/rebuildLeaderboards.tsÂ function, which needs to read allÂ profilesÂ data.
Admin functions for content management.
Webhook handlers that update data based on external events (e.g., Stripe).
Caution:Â Use the service role key sparingly and only within trusted server-side code.
3. Authentication & Onboarding
Utilizing Supabase's built-inÂ authÂ schema and GoTrue-powered services.
3.1 Email/Password + Magicâ€‘Link
Email/Password:Â Standard sign-up and sign-in flow. Supabase handles email confirmation, password resets. Client-side (Swift) will useÂ supabase.auth.signUp(email:password:)Â andÂ supabase.auth.signIn(email:password:).
Magicâ€‘Link:Â Passwordless login. User enters email, receives a link, clicks it to log in. Client-side:Â supabase.auth.signInWithOtp(email:). Deep linking must be configured in the iOS app to handle the magic link URL.
OAuth (Stretch Goal):
Integrate "Sign in with Apple" and "Sign in with Google" for convenience.
Requires configuration in Supabase dashboard (client IDs, secrets) and corresponding setup in Apple Developer portal / Google Cloud Console.
Client-side:Â supabase.auth.signInWith(provider: .apple / .google).
Offline Tolerance & Cached Mode:
If login/API calls fail due to no network connectivity, the app should gracefully degrade.
Detection:Â UseÂ NWPathMonitorÂ in Swift to detect network status.
Behavior:
Display a prominent banner (e.g., "Offline Mode: Some features may be unavailable").
Allow access to locally cached data (e.g., previously synced flashcards from SQLite, downloaded lesson content).
Disable features requiring network (e.g., starting new games, booking sessions, fetching new content).
Queue up actions (like card review submissions) to be synced when connectivity is restored.
This implies a local caching strategy (see 4.1 FlashcardService).
3.2 Automatic Profile Seed
Ensures essential user-specific records are created immediately upon new user registration.
SupabaseÂ after insertÂ Trigger onÂ auth.users:Â This is the preferred, more robust method.
A PostgreSQL function (e.g.,Â handle_new_user()) is created:
      CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (user_id, display_name) -- display_name could be derived from email initially
  VALUES (NEW.id, SUBSTRING(NEW.email FROM 1 FOR POSITION('@' IN NEW.email) - 1));

  -- Optionally, seed initial progress for a default language if desired
  -- INSERT INTO public.user_band_progress (user_id, band_id)
  -- VALUES (NEW.id, (SELECT band_id FROM bands WHERE language_id = <default_lang_id> AND order_idx = 0 LIMIT 1));
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();
    
SECURITY DEFINERÂ allows the function to run with the permissions of the user who defined it (typically an admin), enabling it to insert intoÂ public.profiles.
Swift Fallback (Client-Side Attempt):Â Less ideal due to potential race conditions or client-side failures, but can serve as a backup.
After successful sign-up/first login, the Swift app attempts to fetch the user's profile fromÂ /rest/v1/profiles?user_id=eq.{auth.uid()}&select=*.
If this returns a 404 (or an empty array, depending on Supabase client behavior for empty results with RLS), it means the profile wasn't created by the trigger (or the trigger failed).
The client then makes an idempotent POST request to a Supabase Edge Function orÂ rpcÂ (Remote Procedure Call) endpoint, e.g.,Â rpc.init_user_profile().
ThisÂ rpc.init_user_profile()Â function would attempt toÂ INSERT ... ON CONFLICT DO NOTHINGÂ intoÂ profilesÂ andÂ user_band_progressÂ to ensure it only creates records if they don't exist.
4. Core Learning Loop â€“ Service Layer (Swift)
These services encapsulate the business logic for the main learning activities, interacting with Supabase via the Swift client library and managing local state/cache where appropriate. They are designed to be testable and independent of UI.
4.1 FlashcardService
Manages the Spaced Repetition System (SRS) logic and flashcard data.
SMâ€‘2 Algorithm Implementation:
A pure Swift struct or class implementing the SM-2 algorithm precisely.
Key inputs: user's quality of response (e.g., 0-5 scale mapping to "Blackout," "Incorrect," "Difficult," "Good," "Easy"), current interval, ease factor, repetitions.
Key outputs: new interval, new ease factor, updated repetitions.
Ease Factor Floor:Â The ease factor (EF) will not drop below 1.3, preventing cards from becoming stuck in extremely short review cycles if consistently answered poorly.
calculateNextReview(quality: Int, interval: Int, easeFactor: Double, repetitions: Int) -> (newInterval: Int, newEaseFactor: Double, newRepetitions: Int, nextReviewDate: Date)
Local Cache (SQLite via GRDB.swift or Core Data):
Purpose:Â Enables offline flashcard drills and faster UI loading.
Schema:Â Mirrors relevant parts ofÂ cardsÂ andÂ card_reviewsÂ tables (e.g.,Â card_id,Â target_text,Â native_text,Â audio_url,Â image_url,Â interval,Â ease_factor,Â next_review_at).
Synchronization:
Initial Sync/Delta Sync:Â When online, fetches due cards and cards for active lessons from Supabase and updates the local SQLite DB.
Offline Drills:Â When offline,Â FlashcardServiceÂ reads from and writes review updates (new SRS parameters,Â last_reviewed_at) to SQLite.
Sync Queue & Flush:Â Review updates made offline are added to a "sync queue" (could be a separate SQLite table or in-memory array persisted to disk). When network connectivity is restored, this queue is processed, and updates are batch-POSTed to theÂ card_reviewsÂ table in Supabase. UseÂ UPSERT(insert on conflict update) forÂ card_reviews.
Fetching Due Cards:
getDueCards(limit: Int) -> AnyPublisher<[CardReviewData], Error>: Fetches cards whereÂ next_review_at <= today()Â from local cache, ordered by urgency.
4.2 LearnService
Manages the presentation of new lesson content and associated exercises.
Fetching Lessons:
getLessonsForBand(bandId: Int) -> AnyPublisher<[Lesson], Error>
SQL equivalent:Â SELECT * FROM lessons WHERE band_id = :activeBand AND lesson_id NOT IN (SELECT lesson_id FROM user_lesson_progress WHERE user_id = :userId AND completed_at IS NOT NULL) ORDER BY order_idx;
(Assumes aÂ user_lesson_progressÂ table to track lesson completion:Â user_id, lesson_id, completed_at).
Generating Distractors for Exercises (e.g., multiple-choice questions):
When a card/concept is presented in a multiple-choice format, effective distractors are crucial.
Strategy:
Identify the correctÂ card.
Fetch 2-3 otherÂ cardsÂ from the sameÂ lessonÂ orÂ unitÂ (sibling cards).
Ensure distinctness:
Distractors should not have the sameÂ native_textÂ (translation) as the correct answer.
Ideally, distractors should be semantically related but clearly incorrect (e.g., for "apple," distractors might be "pear," "banana," not "car"). This often requires manual curation or more advanced NLP if fully automated.
Avoid distractors that are too obviously wrong or too similar to the correct answer, making the choice trivial or confusing.
This logic might reside within theÂ LearnServiceÂ or be part of theÂ content_jsonÂ structure for lessons if distractors are pre-defined.
4.3 ReviewService
Focuses on cards that the user has struggled with or are due for SRS review. This is distinct from learningÂ newÂ cards.
Fetching Cards for Review:
getReviewItems(limit: Int = 10) -> AnyPublisher<[ReviewableCard], Error>
Combines two sources:
Error-Driven:Â Cards fromÂ learn_errorsÂ where the user has previously made mistakes. Prioritize cards with higherÂ error_countÂ or more recentÂ last_error_at.
SRS-Driven:Â Cards fromÂ card_reviewsÂ whereÂ next_review_at <= today().
SQL equivalent (simplified):
      (
  SELECT c.*, lr.last_error_at AS sort_key, 'error' as source
  FROM cards c JOIN learn_errors lr ON c.card_id = lr.card_id
  WHERE lr.user_id = :userId
)
UNION ALL
(
  SELECT c.*, cr.next_review_at AS sort_key, 'srs' as source
  FROM cards c JOIN card_reviews cr ON c.card_id = cr.card_id
  WHERE cr.user_id = :userId AND cr.next_review_at <= NOW()::date
)
ORDER BY sort_key ASC -- or DESC depending on how you want to prioritize
LIMIT :limit;
    
IGNORE_WHEN_COPYING_START
content_copyÂ downloadÂ 
Use codeÂ with caution.Â SQL
IGNORE_WHEN_COPYING_END
The service would then apply further logic to de-duplicate and potentially interleave these items intelligently.
4.4 BossBattleService
Manages the state and logic for the end-of-band assessments ("Boss Battles").
State Machine:Â Manages the flow of the Boss Battle.
enum BossBattleState { case intro, inProgress(startTime: Date, remainingTime: TimeInterval), completed(score: Double), passed, failed }
Uses Combine'sÂ @PublishedÂ property to expose state changes to the UI.
Fetching Test Definition:
getBossTest(bandId: Int) -> AnyPublisher<BossTest, Error>: Fetches fromÂ boss_testsÂ table.
Timer Logic:
Driven viaÂ Timer.publish(every: 0.1, on: .main, in: .common).autoconnect()Â from the Combine framework.
Updates aÂ @Published var remainingTime: TimeIntervalÂ property.
UI elements (like a progress bar) subscribe toÂ remainingTime.
Answer Submission & Scoring:
Accepts user answers for each item inÂ boss_tests.items_json.
Calculates score based on correct answers vs. total items.
Atomic Supabase Update on Pass/Fail:
When the battle is completed, results are submitted to Supabase within a transaction to ensure atomicity, especially when updatingÂ user_band_progress.
UsesÂ rpcÂ for transactional updates if complex logic is involved:
      -- Supabase RPC function: complete_boss_battle(user_id_in, band_id_in, score_in, passed_in)
BEGIN;
-- Log the attempt (e.g., into a boss_attempts table)
INSERT INTO boss_attempts (user_id, band_id, score, passed, attempted_at)
VALUES (user_id_in, band_id_in, score_in, passed_in, now());

-- If passed, update progress
IF passed_in THEN
  UPDATE user_band_progress
  SET boss_passed = TRUE, passed_at = now(), units_completed = (SELECT units_required FROM bands WHERE band_id = band_id_in) -- Mark all units as done
  WHERE user_id = user_id_in AND band_id = band_id_in;
END IF;
COMMIT;
    
IGNORE_WHEN_COPYING_START
content_copyÂ downloadÂ 
Use codeÂ with caution.Â SQL
IGNORE_WHEN_COPYING_END
The Swift service calls this RPC:Â supabase.rpc("complete_boss_battle", params: [...]).
4.5 GamificationService
Central hub for managing XP, levels, streaks, and broadcasting game-related events.
XP Table & Logic:Â Defines XP awards for various actions.
Card review (SM-2 "Easy" or "Good"): 5 XP
Lesson completion: 15 XP
Bonus for zero errors during lesson exercises: +5 XP (total 20 XP)
Boss Battle pass: 100 XP
Quick-talk (asynchronous audio game) win: 50 XP
Quick-talk loss/draw: 15 XP (participation reward)
Live teacher session (video, â‰¥ 15 minutes duration): 120 XP
Level Formula:
level = floor(sqrt(total_xp / 50))
This provides a non-linear progression, requiring more XP for higher levels. The constantÂ 50Â can be tuned.
XP thresholds for levels: Level 1 (0 XP), Level 2 (50 XP), Level 3 (200 XP), Level 4 (450 XP), etc.
Streak Management:
On app open / relevant activity, checkÂ profiles.last_active_atÂ (a new column might be needed, or infer from lastÂ xp_event).
IfÂ today - last_active_at == 1 day, incrementÂ profiles.streak.
IfÂ today - last_active_at > 1 day, resetÂ profiles.streakÂ to 1 (if activity today) or 0.
UpdateÂ profiles.last_active_atÂ toÂ now().
Progress Rings Data Source:Â Provides data for UI elements.
Global Progress:Â (Total bands passed for current language) / (Total bands available in current language)
SELECT COUNT(*) FROM user_band_progress WHERE user_id = :uid AND language_id = :lid AND boss_passed = TRUE
SELECT COUNT(*) FROM bands WHERE language_id = :lid
Current Band Progress:Â user_band_progress.units_completedÂ /Â bands.units_requiredÂ for the active band.
Boss Battle Eligibility/Status:Â user_band_progress.units_completed >= bands.units_requiredÂ (eligible) ANDÂ !user_band_progress.boss_passedÂ (not yet passed) â†’ Show Boss Battle CTA. IfÂ boss_passedÂ â†’ 100%.
Event Emission for Reactive UI:
let gameEventPublisher = PassthroughSubject<GameEvent, Never>()
enum GameEvent { case xpEarned(amount: Int, newTotalXp: Int), levelUp(newLevel: Int), streakExtended(days: Int), streakLost }
When XP is awarded, level changes, or streak updates, theÂ GamificationServiceÂ callsÂ gameEventPublisher.send(...).
UI components (e.g., XP bar, level display, profile screen) subscribe toÂ gameEventPublisherÂ to reactively update themselves without tight coupling.
Updating Supabase:
All gamification changes (XP, level, streak) are persisted to theÂ profilesÂ table.
AnÂ xp_eventsÂ table can log individual XP gains for audit/history:Â (event_id, user_id, amount, source_type, source_id, created_at).Â source_typeÂ could be 'lesson', 'review', 'boss', 'quick_game_win'.
5. User Interface â€“ Screen Blueprints (SwiftUI)
Focus on key interactions, information hierarchy, and visual design language.
5.1 StudyMenuView (Main Dashboard / Home Screen)
The primary entry point after login, offering an overview and navigation.
LanguagePillScroller:
AÂ ScrollView(.horizontal)Â containing aÂ LazyHStackÂ of "pills" (capsule-shaped buttons).
Each pill represents a language the user is learning or can start learning (e.g., "ðŸ‡ªðŸ‡¸ Spanish", "ðŸ‡«ðŸ‡· French", "âž• Add Language").
Tapping a language pill updates anÂ AppState.selectedLanguage: LanguageÂ observable object, which other views react to, filtering content dynamically.
RecentActivityList / "What's New" Feed:
Displays a summary of recent achievements or notable events (e.g., "You extended your streak to 5 days!", "New Boss Battle unlocked for Spanish N2!", "You won a Quick Talk game!").
Data sourced from a local cache ofÂ xp_eventsÂ or a dedicatedÂ user_notificationsÂ table.
UsesÂ ListÂ with aÂ DiffableDataSourceÂ (orÂ ForEachÂ with identifiable data) for efficient updates. Each item could be a custom cell with an icon and descriptive text.
5.2 LanguageDashboardView (Per-Language Home)
Accessed after selecting a language fromÂ StudyMenuView. Focuses on progress within that specific language.
ScrollView Container:Â The main view is aÂ ScrollViewÂ to accommodate varying content height.
HeaderCard:Â A prominent card at the top.
Displays the selected language name and flag.
Features a large circular progress ring visualizingÂ Global ProgressÂ (total bands passed / total bands in language).
The ring's fill uses an animatedÂ kaleidoscope gradientÂ (e.g.,Â AngularGradientÂ with shifting colors) for visual appeal.
BandTracker:Â A horizontally scrollableÂ ScrollView(.horizontal)Â with aÂ LazyHStackÂ ofÂ BandChipÂ views.
BandChip: Represents a proficiency band (e.g., "N1," "N2," "I1").
Displays the band'sÂ short_label.
Contains a smaller sub-progress ring showingÂ units_completed / units_requiredÂ for that band.
Shows a status icon:
ðŸ”’ (Lock icon): Band is not yet accessible (previous band not passed).
â–¶ï¸ (Play icon / Active highlight): Current active band the user is working on.
âœ… (Checkmark icon): Band has been completed (Boss Battle passed).
Tapping an accessible band chip might scroll theÂ StudyModesCarouselÂ to focus on that band or navigate to a band-specific overview.
StudyModesCarousel:Â AÂ TabViewÂ withÂ TabViewStyle(.page(indexDisplayMode: .never))Â to create a swipeable carousel for Learn, Review, and Boss modes for theÂ currently active band.
LearnCard: CTA to start or continue the next available lesson in the active band. Shows progress like "Lesson 3/10".
ReviewCard: CTA to start a review session. Shows number of due cards/errors, e.g., "15 Cards Due."
BossCard: CTA to attempt the Boss Battle for the active band. Only active ifÂ units_completed >= units_required. Shows status like "Ready to Battle!" or "Complete 2 more units."
FlashcardSection:
Displays a small sample of recently learned or due flashcards (e.g., 3-5 cards horizontally scrollable).
If no cards are associated with the user yet (e.g., new user, new language), it shows a CTA button: "Add Cards by Completing Your First Lesson!"
5.3 LearnView / ReviewView (Core Study Interface)
The screen where users interact with individual flashcards or lesson exercises.
Card Style & Glassmorphism:
Cards are presented with a "glassmorphism" effect:
AÂ Material.thickÂ orÂ Material.ultraThinMaterialÂ background (from SwiftUI) provides the blur.
RoundedRectangle(cornerRadius: 20)Â for the shape.
SubtleÂ borderÂ andÂ shadow(radius: 10)Â to lift it off the page.
Content (text, images) is placed on top of this blurred background.
Gesture Navigation:
Swipe Left (Incorrect/Hard):Â User swipes the card left to indicate they didn't know the answer or found it difficult.
Swipe Right (Correct/Easy):Â User swipes right for a correct answer.
Swipe Up/Down (Skip - Optional):Â Could be used to skip a card if undecided, moving it to the back of the current queue.
Undo Functionality:Â A dedicated "Undo" button allows the user to go back to theÂ immediately previousÂ card and re-evaluate their answer. This state (previous card and its answer) needs to be temporarily stored. Limited to one step back to prevent gaming the system.
Audio Playback:
For cards with audio, a speaker icon button is present.
UsesÂ AVFoundation'sÂ AVAudioPlayerÂ (orÂ AVAudioEngineÂ withÂ AVAudioPlayerNodeÂ for more control if sound effects or mixing are needed).
Aim forÂ zero-latency playbackÂ on tap by pre-loading or efficiently streaming audio. If audio URLs are from Supabase Storage, consider local caching of frequently accessed audio files.
Input Methods:
Multiple Choice: Tap to select.
Text Input: NativeÂ TextFieldÂ for translation or fill-in-the-blanks.
Self-Assessment Buttons: "Easy," "Good," "Hard," "Again" buttons for SRS input after revealing the answer.
5.4 BossBattleView
The interface for timed, end-of-band assessments.
Radial Timer:
A circular progress bar animates around the border of the screen or around a central element, visually depleting as time runs out.
Implemented usingÂ CircleÂ shape withÂ .trim(from: 0, to: progress)Â andÂ stroke.
TheÂ progressÂ value is updated by theÂ BossBattleService's timer.
Haptic Feedback:
UINotificationFeedbackGeneratorÂ orÂ UIImpactFeedbackGeneratorÂ provides haptic cues:
Subtle tap when time is 50% gone.
More insistent taps or vibration when 10 seconds remaining.
A distinct haptic for test submission or time up.
Question Presentation:Â Mixed-modality questions are presented one by one. Clear "Next" button.
Result Sheet:
Presented modally (.sheet) upon completion.
Shows score, pass/fail status, XP earned.
Includes aÂ Share Card (UIImage Renderer):
A graphically rich summary of the achievement (e.g., "I passed the Spanish N2 Boss Battle on Tong!").
Generated by rendering a SwiftUI view hierarchy into aÂ UIImageÂ usingÂ ImageRendererÂ (iOS 16+).
This image can then be shared via the standard iOS Share Sheet (UIActivityViewController).
5.5 FlashcardDrillView (Dedicated SRS Practice Screen)
Optimized for rapid review of flashcards.
Flip Animation:
Cards have a front (e.g., target language word) and a back (e.g., native translation, example sentence).
Tapping the card triggers a flip animation.
Achieved usingÂ UIView.transition(with:duration:options:animations:completion:)Â withÂ .transitionFlipFromRightÂ orÂ .transitionFlipFromLeft, bridged into SwiftUI using aÂ UIViewRepresentablewrapper if a native SwiftUIÂ matchedGeometryEffectÂ orÂ .rotation3DEffectÂ isn't sufficient or performant enough.
Keyboard Shortcuts (for iPad / External Keyboards):
Space bar: Maps to the "Easy" or "Reveal Answer" button.
Number keys (1-4): Could map to difficulty ratings ("Again," "Hard," "Good," "Easy").
Implemented usingÂ .keyboardShortcut()Â SwiftUI modifier.
5.6 QuickGameViews (Asynchronous Audio-Only Duels)
Interface for managing and playing turn-based asynchronous audio games.
Game List View:Â Shows active games, pending invites, completed games. Each item shows opponent, last turn time, whose turn it is.
Game Play View (Audio-Focused):
Predictive Turn ETA Bar:
Visually indicates how much time the opponent has left to make their turn (e.g., "Opponent has 8 hours left"). Max 12 hours by default, configurable.
Calculated fromÂ quick_games.last_turn_atÂ + turn_duration_limit.
Could be a shrinking progress bar or just text.
Voice Recording Interface:Â Mic button, waveform visualization during recording, timer for audio input.
GameTimeline / Chat History (Audio Turns):
AÂ ListÂ orÂ ScrollViewÂ displaying turns as chat bubbles (player's on right, opponent's on left).
Each bubble contains:
Player avatar/name.
Audio player for the voice note.
Transcript of the voice note.
Optionally, a summary of AI feedback for that turn (e.g., WPM, key phrases).
Turns are grouped by day (e.g., "Today," "Yesterday," "May 17") using aÂ DiffableDataSourceÂ with sections or custom grouping logic.
5.7 VideoCallView (Live Teacher Sessions Only)
Interface for real-time WebRTC video calls exclusively with teachers.
Layout & Controls:
Main view for remote teacher's video.
Picture-in-Picture (PiP) draggable view for local camera preview.
Controls: Mute/unmute microphone, enable/disable camera, flip camera (front/rear), end call.
Optional: Chat messaging overlay for text communication during the video call.
Adaptive to Split-Screen Multitasking (iPad):
The UI should reflow gracefully when the app enters iPadOS split-screen mode. Video views might need to resize, controls might rearrange.
Test with various split ratios.
Picture-in-Picture (System Level for Backgrounding):
When the user backgrounds the app during a teacher call, the video call should continue in a system PiP window (requiresÂ AVKitÂ and specific entitlements likeÂ com.apple.developer.avfoundation.multitasking-camera-access).
5.8 Accessibility & Localization
Ensuring the app is usable by everyone.
Accessibility:
Target Size:Â All interactive controls (buttons, toggles, list items) must have a minimum tap target size of 44x44 points. Use padding orÂ .contentShape(Rectangle())Â to increase tap areas if visual elements are smaller.
VoiceOver:
All UI elements must have descriptiveÂ accessibilityLabels.
Elements that change state (e.g., play/pause button) should update their label or hint.
Custom controls need to implementÂ UIAccessibilityÂ protocol methods if using UIKit components, or use SwiftUI accessibility modifiers (.accessibilityValue(),Â .accessibilityHint(),Â .accessibilityAction()).
Labels are localized.
Dynamic Type:Â All text should scale correctly with the user's preferred font size settings. Use SwiftUI'sÂ .font(.system(...))Â or custom fonts that support dynamic type.
Color Contrast:Â Ensure sufficient contrast between text and background colors (WCAG AA standard).
Localization:
All user-facing strings are stored inÂ Localizable.stringsÂ files for each supported language.
UseÂ NSLocalizedStringÂ or SwiftUI'sÂ Text("key")Â which automatically looks up keys.
Layouts must supportÂ Right-to-Left (RTL) languagesÂ (e.g., Arabic, Hebrew). SwiftUI handles most mirroring automatically ifÂ environment(\.layoutDirection)Â is respected. Test thoroughly.
Dates, times, and numbers are formatted according to the user's locale.
6. AI & Edgeâ€‘Function Pipelines (Deno/TypeScript)
Serverless functions orchestrating AI model interactions and backend logic. These run on Supabase's Deno-based Edge Function environment.
6.1 Voiceâ€‘Note Analysis Pipeline (Function:Â ai/processPracticeAudio.ts)
Triggered typically by a Supabase Storage event (new file uploaded to a specificÂ practice-audioÂ bucket) or a direct HTTP call from the client after upload. This is for self-study voice notes.
Validate Storage Event / Input:
If triggered by Storage: Parse event payload to get bucket ID and object path.
If HTTP: Validate JWT for auth, parse request body for audio URL or metadata.
Security/Cost Control:
Retrieve file metadata (e.g., using Supabase Storage API orÂ ffprobeÂ if file is downloaded).
Reject files > 5 MB (configurable limit).
Reject audio duration > 30 seconds (configurable).Â ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 audio.wavÂ can get duration.
Download & Pre-process Audio:
Download the audio file from Supabase Storage into the Edge Function's temporary memory/filesystem.
Down-sample with ffmpeg:Â Convert to 16 kHz mono WAV format. This is often optimal for speech recognition APIs like Whisper and reduces file size/processing cost.
FFmpeg can be bundled with the Edge Function or accessed via a WASM version if available and practical for Deno. A simpler approach might be to ensure the client uploads in the correct format, but server-side normalization is more robust.
Command:Â ffmpeg -i input.mp4 -ac 1 -ar 16000 output.wavÂ (example).
Transcribe with Whisper V3:
Construct aÂ POSTÂ request to the Whisper V3 API endpoint.
Include the (down-sampled) audio file data in the request body (e.g.,Â multipart/form-data).
Set appropriate headers (Authorization with Whisper API key, Content-Type).
Handle API response: Parse the JSON transcript. Error handling for API failures (rate limits, bad audio).
Analyze with DeepSeek V3:
Construct Prompt:
      {
  "model": "deepseek-coder", // Or appropriate chat model if V3 has one
  "messages": [
    {
      "role": "system",
      "content": "You are a CEFR B2 level English pronunciation and fluency coach. Analyze the provided transcript. Identify potential mispronunciations (suggest correct pronunciation if possible), calculate words per minute (WPM), and provide 1-2 concise, actionable tips for improvement. Respond in JSON format with keys: 'wpm', 'potential_mispronunciations' (array of objects with 'word' and 'suggestion'), 'fluency_tips' (array of strings)."
    },
    {
      "role": "user",
      "content": "Transcript: \"${transcriptFromWhisper}\" Original audio duration: ${durationInSeconds} seconds."
    }
  ],
  "temperature": 0.3 // Lower temperature for more deterministic feedback
}
    
IGNORE_WHEN_COPYING_START
content_copyÂ downloadÂ 
Use codeÂ with caution.Â Json
IGNORE_WHEN_COPYING_END
POST this JSON to the DeepSeek V3 API endpoint.
Handle API response: Parse the JSON feedback. Error handling.
Store Results:
Insert a new row into theÂ practice_reportsÂ table in Supabase.
IncludeÂ user_id,Â language_id, originalÂ audio_url, WhisperÂ transcript,Â sample_rateÂ (e.g., 16000), calculatedÂ wpm, theÂ mispronunciationsÂ array, andÂ fluency_tipsÂ from DeepSeek's JSON output.
Optionally, send a Supabase Realtime message or push notification to the client indicating the report is ready.
6.2 Quickâ€‘Game Turn Processor (Function:Â games/processTurn.ts)
Triggered when a user submits their audio turn in an asynchronous Quick Game.
Input Validation:Â ReceiveÂ game_id,Â player_id,Â audio_urlÂ (from client after upload to Storage). Validate that it's this player's turn in the specified game.
Voice Analysis (Reuses parts of 6.1 for audio processing):
Download audio, down-sample if needed.
Transcribe with Whisper V3.
DeepSeek Analysis (Modified Prompt for Game Context):
      {
  "model": "deepseek-coder", // Or chat model
  "messages": [
    {
      "role": "system",
      "content": "You are analyzing a turn in a spoken language game. Based on the transcript, calculate words per minute (WPM), count unique words, and estimate the filler-word ratio (e.g., uh, um). Identify 1-2 key phrases or vocabulary used. Respond in JSON: {'wpm', 'unique_word_count', 'filler_word_ratio_pct', 'key_phrases': []}."
    },
    {
      "role": "user",
      "content": "Transcript: \"${transcript}\" Audio duration: ${durationInSeconds} seconds."
    }
  ]
}
    
IGNORE_WHEN_COPYING_START
content_copyÂ downloadÂ 
Use codeÂ with caution.Â Json
IGNORE_WHEN_COPYING_END
Store Turn Data:
Insert a new row intoÂ quick_game_turnsÂ withÂ game_id,Â player_id,Â turn_number,Â audio_url,Â transcript, and the AI analysis JSON.
Update Game State:
Update theÂ quick_gamesÂ table: setÂ current_turn_player_idÂ to the opponent, updateÂ last_turn_at.
Check for game completion conditions (e.g., max turns reached). If completed, calculate Elo, determine winner (could be AI-judged based on metrics or a simple rule for now), and update game status.
Notify Opponent:
Send a Supabase Realtime message on a channel specific to the game (e.g.,Â quick-game:${game_id}) or the opponent's user channel.
Payload:Â { type: 'NEW_TURN', gameId: '...', nextPlayerId: '...' }.
This triggers a push notification or in-app update for the opponent.
6.3 Postâ€‘Session Analysis (Function:Â ai/processSession.tsÂ for Teacher Video Lessons)
Triggered after a live teacher video session ends, usually by the client app signaling completion and providing URLs to recorded audio tracks from the video call.
Input:Â booking_id,Â student_audio_url,Â teacher_audio_urlÂ (or a single mixed audio URL if client-side/server-side mixing is done during the video call).
Audio Processing:
Download audio tracks.
Merge Tracks (if separate):Â UseÂ ffmpegÂ to combine student and teacher audio into a single stereo or dual-mono track.Â ffmpeg -i student.wav -i teacher.wav -filter_complex "[0:a][1:a]amerge=inputs=2[aout]" -map "[aout]" output_merged.wav
(Alternative: If client records a single mixed track, this step is simpler).
Diarized Transcription with Whisper V3 (or specialized diarization API):
Send the merged audio to Whisper V3. Some Whisper implementations or wrappers support speaker diarization (identifying who spoke when). If Whisper V3 itself doesn't offer robust diarization, an additional step with a dedicated diarization model/API might be neededÂ beforeÂ orÂ afterÂ transcription to segment the transcript by speaker.
The goal is a transcript like:Â [Student: "Hello, how are you?"] [Teacher: "I'm fine, thanks! And you?"]
DeepSeek Grammar & Fluency Rubric for Student (from Teacher Session):
Extract only the student's utterances from the diarized transcript.
Construct Prompt:
      {
  "model": "deepseek-coder", // Or chat model
  "messages": [
    {
      "role": "system",
      "content": "You are an expert language tutor analyzing a student's performance in a conversation with a teacher. Based on their utterances, evaluate their: \n1. Fluency (flow, hesitations, pace) \n2. Grammatical Accuracy (correctness of structures) \n3. Lexical Complexity (range and appropriateness of vocabulary) \nScore each on a scale of 0-5. Provide specific examples from the transcript to support your scores and offer 2-3 targeted suggestions for improvement. Respond in JSON: {'scores': {'fluency': 0-5, 'accuracy': 0-5, 'complexity': 0-5}, 'strengths': [string], 'areas_for_improvement': [{'example_from_transcript': string, 'suggestion': string}]}"
    },
    {
      "role": "user",
      "content": "Student's utterances: \"${student_transcript_segments}\""
    }
  ]
}
    
IGNORE_WHEN_COPYING_START
content_copyÂ downloadÂ 
Use codeÂ with caution.Â Json
IGNORE_WHEN_COPYING_END
POST to DeepSeek, parse JSON response.
Store Analysis:
Insert intoÂ session_analysisÂ table:Â booking_id,Â student_id,Â teacher_id, URL to the (potentially stored) diarized transcript, and the structured JSON feedback from DeepSeek.
6.4 Payment Webhook Handler (Function:Â payments/webhook.ts)
An HTTP endpoint exposed by Supabase Edge Functions to receive webhooks from Stripe.
Verify Stripe Signature:
Crucial for security. Use theÂ stripe.webhooks.constructEvent()Â method from the Stripe Node.js SDK (or equivalent Deno library).
Requires the raw request body and theÂ Stripe-SignatureÂ header. The webhook signing secret is stored as an environment variable.
If verification fails, returnÂ 400 Bad Request.
Idempotency:
Stripe events have anÂ idÂ (e.g.,Â evt_xxxx). Store processed event IDs (e.g., in a simpleÂ processed_stripe_eventstable withÂ event_id TEXT PRIMARY KEY, processed_at TIMESTAMPTZ) to prevent duplicate processing if Stripe retries a webhook.
IfÂ event.idÂ already exists, returnÂ 200 OKÂ immediately.
Handle Event Types (e.g.,Â switch (event.type)):
customer.subscription.created,Â customer.subscription.updated:
ExtractÂ customer_id,Â subscription_id,Â status,Â current_period_endÂ fromÂ event.data.object.
Update theÂ profilesÂ table:
UPDATE profiles SET pro_subscription = (status === 'active' || status === 'trialing'), pro_subscription_expires_at = to_timestamp(current_period_end), stripe_customer_id = customer_id, stripe_subscription_id = id WHERE stripe_customer_id = customer_id;Â (or map user viaÂ metadataÂ ifÂ user_idÂ was passed to Stripe).
Send an in-app message via Supabase Realtime to the user confirming their Pro status.
customer.subscription.deleted:
SetÂ pro_subscription = FALSEÂ inÂ profiles.
invoice.payment_succeeded:
If for a one-time booking (teacher session): UpdateÂ bookingsÂ table status toÂ confirmed. Send confirmation notification.
invoice.payment_failed:
Notify user, potentially update subscription status if it leads to cancellation.
ReturnÂ 200 OK:Â Acknowledge receipt of the webhook to Stripe.
6.5 Leaderboard Rebuilder (Function:Â scheduler/rebuildLeaderboards.ts)
A scheduled Edge Function (e.g., runs daily or hourly via Supabase's pg_cron or an external cron job service hitting an HTTP trigger).
Clear Existing Cache:Â DELETE FROM leaderboard_cache WHERE leaderboard_type IN ('weekly_xp', 'all_time_xp', ...);
Calculate Weekly Rolling XP:
RequiresÂ xp_eventsÂ table:Â SELECT user_id, SUM(amount) as weekly_score FROM xp_events WHERE created_at >= NOW() - INTERVAL '7 days' GROUP BY user_id ORDER BY weekly_score DESC LIMIT 100;
Iterate andÂ INSERT INTO leaderboard_cache (leaderboard_type, rank, user_id, score) VALUES ('weekly_xp', rank_num, user_id, weekly_score);
Calculate All-Time XP:
SELECT user_id, xp as total_score FROM profiles ORDER BY total_score DESC LIMIT 100;
Iterate and insert intoÂ leaderboard_cacheÂ withÂ leaderboard_type = 'all_time_xp'.
Calculate Elo Ranking Percentiles (per language):
For eachÂ language_id:
SELECT user_id, elo, PERCENT_RANK() OVER (ORDER BY elo DESC) as percentile FROM profiles WHERE EXISTS (SELECT 1 FROM user_band_progress ubp WHERE ubp.user_id = profiles.user_id AND ubp.band_id IN (SELECT band_id FROM bands WHERE language_id = :current_language_id)) ORDER BY elo DESC LIMIT 100;
Iterate and insert intoÂ leaderboard_cacheÂ withÂ leaderboard_type = 'elo_lang_XX'Â (e.g.,Â elo_lang_es). Score could be Elo, or rank based on Elo.
Result:Â leaderboard_cacheÂ table is populated with fresh data, enabling O(1) (actually O(N) for top N, but very fast) reads for leaderboard displays in the app.Â SELECT * FROM leaderboard_cache WHERE leaderboard_type = 'weekly_xp' ORDER BY rank ASC;
7. Monetisation & Feature Gating
Strategies for revenue generation and managing access to premium features.
7.1 Paywall Flow
Triggered when a free-tier user attempts to access a Pro feature beyond their quota.
Condition:Â !profiles.pro_subscription AND (ai_calls_today >= daily_ai_limit OR active_quick_games >= max_concurrent_games).
TrackingÂ ai_calls_todayÂ andÂ active_quick_gamesÂ might require additional columns onÂ profilesÂ or related tables, updated by Edge Functions or triggers.
Presentation:Â Show aÂ FullScreenCoverÂ SwiftUI view. This is a modal that covers the entire screen.
Content:Â Compelling copy highlighting Pro benefits (unlimited AI, more games, support teachers, etc.). Clearly display monthly/annual pricing options. "Restore Purchases" button.
A/B Testing Price Copy/Layout (viaÂ remote_config):
Fetch paywall configuration fromÂ remote_configÂ table (e.g., key:Â paywall_config_v1).
valueÂ JSON:Â {"headline": "Unlock Your Fluency Faster!", "price_options": [{"id": "monthly", "display": "$9.99/month"}, {"id": "annual", "display": "$79.99/year", "badge": "Save 30%"}]}
The app dynamically renders the paywall based on this config. Different user segments (see 11.2 A/B Framework) might receive different paywall configurations.
Purchase Action:Â Tapping a price option initiates the Stripe purchase flow using the Stripe iOS SDK.
Success/Failure:Â On successful purchase, dismiss the paywall, update localÂ pro_subscriptionÂ state, and refresh user profile from Supabase. On failure/cancellation, dismiss or show an error.
7.2 Usage Quotas (Free Tier)
Limits enforced to encourage upgrading to Pro.
AI Voice Notes (Self-Study Practice):Â 3 per day.
Tracked inÂ profiles.daily_ai_voice_notes_usedÂ (reset daily by a scheduler or on first use of a new day).
Quick Games (Asynchronous Audio-Only):Â 2 concurrent active games.
Count active games for user fromÂ quick_gamesÂ table whereÂ status NOT IN ('completed', 'expired').
Live Teacher Sessions (Video):Â Paid only. No free quota.
Enforcement (Client-Side & Server-Side):
Client-Side (Swift):Â Check local state/profile data before allowing action. Provides immediate UX feedback (e.g., disable button, show "Upgrade" prompt).
Server-Side (Edge Functions):Â Crucial. Edge Functions (e.g.,Â ai/processPracticeAudio.ts,Â games/findOpponent.ts)Â mustÂ re-verify quotas against the database before performing costly operations or creating resources. This prevents malicious users from bypassing client-side checks. If quota exceeded, return a specific error code (e.g., 429 Too Many Requests or a custom 403 Forbidden with error details).
8. Realâ€‘Time Communication (WebRTC for Teacher Video Lessons)
For live video/audio sessions exclusively between students and teachers.
8.1 Signalling Server (for Teacher Video Lessons)
Facilitates the negotiation of WebRTC connections (exchanging SDP offers/answers and ICE candidates) for scheduled teacher sessions.
Primary: Supabase Realtime Channel:
A dedicated channel per call room:Â rtc:{roomId}Â (whereÂ roomIdÂ is unique, e.g.,Â booking_idÂ for the teacher session).
Clients (student and teacher iOS apps) subscribe to this channel usingÂ supabase.channel('rtc:{roomId}').
Messages:Â JSON payloads broadcasted on the channel.
{ "type": "offer", "sdp": { ...session_description_protocol... } }
{ "type": "answer", "sdp": { ... } }
{ "type": "ice_candidate", "candidate": { ...ice_candidate_details... } }
{ "type": "user_joined", "userId": "..." }
{ "type": "user_left", "userId": "..." }
The client sending the message excludes itself from receiving its own broadcast if Supabase Realtime supports this, or handles it client-side.
Fallback WebSocket Server (Optional, Feature-Flag Controlled):
ws.tong-signal.appÂ (custom domain for a dedicated WebSocket server).
Rationale:Â If Supabase Realtime exhibits latency > 500ms consistently for signaling messages during teacher sessions, or if its concurrency limits become an issue, a dedicated WebSocket server might be considered.
Feature Flag:Â Controlled byÂ remote_configÂ key likeÂ use_dedicated_signaling_server: true/false. The WebRTC client layer would choose the signaling mechanism based on this flag.
8.2 STUN/TURN Infrastructure (for Teacher Video Lessons)
Essential for NAT traversal in WebRTC, specifically for teacher video sessions.
STUN (Session Traversal Utilities for NAT):Â Helps peers discover their public IP address and port.
Public STUN servers can be used (e.g.,Â stun:stun.l.google.com:19302).
TURN (Traversal Using Relays around NAT):Â Acts as a relay when direct peer-to-peer connection fails for video calls. This is critical for call reliability but incurs bandwidth costs.
DeployÂ coturnÂ Clusters:Â Open-source TURN server software.
HostÂ coturnÂ instances on cloud VMs (e.g., AWS EC2, DigitalOcean Droplets) in multiple regions to minimize latency for users globally:
us-eastÂ (e.g., N. Virginia)
eu-centralÂ (e.g., Frankfurt)
ap-southeastÂ (e.g., Singapore)
Configure with authentication (long-term credentials or time-limited credentials generated per call).
Bandwidth Auditing & Alerts:
coturnÂ logs contain information about data relayed.
Daily Cron Job:Â A script (e.g., Python/Bash running on a utility server or a scheduled Lambda/Cloud Function) parsesÂ coturnÂ logs.
Pipe to CloudWatch Logs (or similar):Â Aggregate logs for centralized analysis and metric extraction (e.g., total GB relayed per day per region for teacher video calls).
CloudWatch Alarm / Slack Alert:Â If daily relayed data > 10 GB/day per region (configurable threshold), send an alert to a Slack channel for investigation. This helps monitor and control TURN server costs for video sessions.
8.3 WebRTC Client Layer (Swift, for Teacher Video Lessons)
Abstraction over the underlying WebRTC library (e.g., GoogleWebRTC) for teacher video calls.
Wrapper Class:Â A Swift classÂ TeacherVideoCallManagerÂ or similar.
InitializesÂ RTCPeerConnectionFactory,Â RTCPeerConnection.
Manages local media streams (RTCAudioTrack,Â RTCVideoTrack).
Handles offer/answer creation and ICE candidate gathering for video calls.
Combine Publishers for State:
@Published var connectionState: RTCIceConnectionState = .new
@Published var remoteVideoTrack: RTCVideoTrack?
@Published var signalingState: RTCSignalingState = .stable
UI views subscribe to these publishers to react to connection changes, display remote video, etc., during teacher sessions.
Auto-Reconnect Logic on ICE Failure (for Teacher Video Calls):
IfÂ RTCIceConnectionStateÂ transitions toÂ failed:
Attempt an ICE restart:Â peerConnection.restartIce().
If restart fails or is not supported, potentially attempt to tear down and re-establish theÂ RTCPeerConnectionÂ after a short delay (with backoff).
Notify the user (student/teacher) of connection issues.
This requires careful state management to avoid race conditions.
9. Scheduling & Booking (Teacher Video Sessions)
9.1 Teacher Availability Console
A simple web application for teachers to manage their schedules for video lessons.
Technology:Â Next.js (React framework) hosted on Vercel or Netlify.
UsesÂ supabase-jsÂ client library for authentication and data interaction.
Authentication:Â Secured by Supabase OAuth or email/password. Teachers log in with their Tong user accounts (assuming aÂ roleÂ column inÂ profilesÂ or a separateÂ teachersÂ table linked toÂ auth.users).
Functionality (CRUD forÂ teacher_slots):
View:Â Calendar display (e.g., using FullCalendar.io or a simpler custom grid) showing existing available and booked slots for video lessons.
Create:Â Allow teachers to define blocks of availability for video lessons. The system would then break these blocks into bookable slot durations (e.g., 30-minute or 1-hour slots).
Update/Delete:Â Modify or remove available (unbooked) video lesson slots.
RLS:Â Teachers can only CRUD theirÂ ownÂ teacher_slotsÂ (enforced by RLS policy:Â USING (auth.uid() = teacher_id)).
9.2 Student Booking Flow (iOS App for Teacher Video Sessions)
Fetch Available Slots:
Client requests available video lesson slots for a specificÂ language_idÂ orÂ teacher_id.
SELECT ts.*, p.display_name as teacher_name FROM teacher_slots ts JOIN profiles p ON ts.teacher_id = p.user_id WHERE ts.status = 'available' AND ts.start_time >= now() AND ts.language_id = :selected_language_id ORDER BY ts.start_time ASC;
Timezone Conversion:Â Server storesÂ start_timeÂ /Â end_timeÂ in UTC (TIMESTAMPTZ). Client displays these times converted to the user's local timezone.
Reserve Slot (Optimistic Lock / Tentative Booking):
When a student selects a video lesson slot, the client calls an Edge FunctionÂ rpc.reserve_slot(slot_id_in).
This function:
Checks if the slot is stillÂ available.
UpdatesÂ teacher_slots.statusÂ toÂ tentative_bookingÂ and sets aÂ tentative_booking_expires_at = now() + INTERVAL '10 minutes'. It also records theÂ student_idÂ attempting the booking.
Returns success/failure to the client.
The client then proceeds to Stripe payment for the video lesson.
A scheduled job or trigger could periodically clean up expiredÂ tentative_bookingÂ slots, reverting them toÂ available.
Stripe Payment & Confirmation:
Client uses Stripe iOS SDK to collect payment details and confirm the payment intent created for this video lesson booking.
Webhook Success (invoice.payment_succeededÂ orÂ payment_intent.succeeded):
TheÂ payments/webhook.tsÂ Edge Function (see 6.4) handles the webhook.
It verifies the payment is for the tentatively booked video lesson slot.
Atomically:
Creates a new row inÂ bookingsÂ table (status = 'confirmed').
UpdatesÂ teacher_slots.statusÂ toÂ bookedÂ and links it to the newÂ booking_id.
Sends confirmation push notifications/Realtime messages to student and teacher for the video lesson.
Rollback/Failure:Â If payment fails or the 10-minute reservation window expires before payment confirmation, theÂ teacher_slots.statusÂ should revert toÂ available. TheÂ payments/webhook.tsÂ or a separate cleanup function handles this.
9.3 Push Notifications (APNs via Firebase Admin SDK or direct APNs)
For timely alerts and re-engagement.
Token Storage:
device_tokensÂ table:Â (user_id UUID, token TEXT, device_os TEXT, created_at TIMESTAMPTZ), withÂ PRIMARY KEY (user_id, token).
Client app registers for push notifications, gets the APNs device token, and sends it to an Edge Function to be stored in this table.
Sending Logic (Edge FunctionÂ notifications/sendPushNotification.ts):
TakesÂ user_id,Â title,Â body,Â payloadÂ (for deep linking) as input.
Fetches APNs token(s) for theÂ user_idÂ fromÂ device_tokens.
Uses Firebase Admin SDK (recommended for cross-platform later and easier API):
admin.messaging().sendToDevice(token, message)
(Or, direct APNs: construct JSON payload, use HTTP/2 client to connect to APNs server).
Handles success/failure responses, prunes invalid/expired tokens fromÂ device_tokens.
Triggers for Push Notifications:
Booking confirmation (student & teacher for video lesson).
Session reminder (e.g., 1 hour and 15 minutes before video lesson).
Quick Game: opponent's audio turn submitted.
Streak reminders (if user hasn't practiced by evening).
New feature announcements (targeted).
10. Quality Assurance & Compliance
10.1 Crash Reporting
Firebase Crashlytics:
Integrate Firebase SDK into the iOS app.
Crashlytics automatically captures and reports crashes.
Custom Keys & Logs:Â Log relevant context (e.g.,Â current_view,Â user_id,Â active_language) to aid debugging:Â Crashlytics.crashlytics().setCustomValue(...),Â Crashlytics.crashlytics().log(...).
App Version Tags:
SetÂ CFBundleVersionÂ (build number) andÂ CFBundleShortVersionStringÂ (marketing version) inÂ Info.plist.
Differentiate builds in Crashlytics dashboard by version to track stability of TestFlight vs. App Store releases. This is usually handled automatically by Crashlytics using these plist values.
10.2 Automated Tests
Unit Tests (XCTest in Swift,Â deno testÂ for Edge Functions):
SMâ€‘2 Math:Â VerifyÂ FlashcardService's SRS calculations for various inputs.
Elo Calculation:Â Test the Elo update logic (likely in an Edge Function or a shared utility) with various win/loss scenarios and K-factors to prevent rating inflation/deflation.
Review Queue Logic:Â TestÂ ReviewService's logic for selecting and prioritizing cards fromÂ learn_errorsÂ andÂ card_reviews.
Edge Function Input Validation:Â Test how functions handle malformed inputs, missing auth, etc.
UI Tests (XCUITest in Swift):
Automate critical user flows:
Onboarding: Sign up, initial profile setup.
Paywall: Triggering paywall, (mocked) purchase flow.
Lesson Completion: Navigating to a lesson, interacting with an exercise, completing it.
Video Call (Teacher Session): (Challenging to fully automate WebRTC) At least test UI elements ofÂ VideoCallView, connecting to a mock signaling server if possible, and basic state changes (connecting, connected, disconnected).
Integration Tests (Can be part of XCUITest or separate):
Test interactions between Swift services and (mocked or local) Supabase backend.
Test Edge Function to Edge Function calls or Edge Function to AI API calls (with mocks for external APIs).
10.3 Observability
Monitoring system health and performance.
Target: Grafana Dashboards:Â Grafana connects to various data sources to create unified dashboards.
Postgres Metrics (from Supabase's provided metrics or a custom exporter if needed):
Transactions Per Second (TPS), query latency, active connections, replication lag, disk/CPU usage.
Edge Function Metrics (Supabase dashboard provides some, or custom logging to a service Grafana can query):
p95/p99 invocation latency, error rates, invocation counts.
AI API Costs & Usage:
Whisper/DeepSeek:Â Track token counts/audio minutes processed per function call. Log this data to a Supabase table or a dedicated analytics service. Create metrics for total daily/hourly usage and estimated cost.
TURN Server Bandwidth (Coturn for Teacher Video Lessons):
As per 8.2, logs piped to CloudWatch. Create CloudWatch metrics for relayed GB, then visualize in Grafana.
Stripe MRR/Revenue:
Stripe provides its own dashboard. If needed, key revenue metrics can be pulled via Stripe API by a scheduled function and stored/visualized in Grafana for a single pane of glass view.
Alerting (Alertmanager or Cloud-native alerting like CloudWatch Alarms):
Rule Example:Â IfÂ Edge Function error_rate (for function X) > 5% for 5 minutes, trigger an alert.
Integration:Â Alertmanager can send notifications to PagerDuty, Slack, email.
Other alerts: High DB CPU, low disk space, excessive TURN bandwidth for video calls, API key nearing expiry.
10.4 Privacy & Compliance
Handling user data responsibly.
Transcript Encryption at Rest (Supabase Storage):
Supabase Storage supports server-side encryption (SSE) with platform-managed keys by default.
For enhanced control (if required by specific compliance regimes), consider client-side encryption before uploading transcripts/audio, or use customer-managed encryption keys (CMEK) if Supabase offers it. AES-256 is a strong standard.
GDPR Export Endpoint (functions/account/exportData.ts):
A secure Edge Function, callable by an authenticated user.
Gathers all personal data related to theÂ auth.uid():
profilesÂ record.
card_reviews,Â learn_errors,Â user_band_progress.
quick_game_turnsÂ (audio URLs, transcripts).
practice_reportsÂ (audio URLs, transcripts, feedback).
bookings,Â session_analysisÂ (transcripts, feedback).
Compiles this data into a machine-readable format (JSON or zipped CSVs).
Provides it as a download or emails a secure link to the user.
Delete Account Functionality:
User-initiated from app settings.
Cascade Delete in Postgres:Â ON DELETE CASCADEÂ on foreign keys ensures that when a user is deleted fromÂ auth.users, their linked data inÂ profiles,Â card_reviews, etc., is automatically removed.
Purge AI Data from S3 (Supabase Storage):
Supabase Storage objects (audio files, transcripts if stored as files) associated with the user need to be deleted.
This might require an Edge Function that lists and deletes objects based onÂ user_idÂ in their path.
Alternatively, if objects are not directly linked via path, aÂ user_data_deletion_queueÂ table could logÂ user_ids, and a cleanup function processes it, deleting associated Storage objects.
S3 Lifecycle Policy (if applicable directly, or mimicked):Â While Supabase Storage abstracts S3, if you had direct S3 access, you could use lifecycle policies to expire objects. For Supabase, manual deletion via API is typical.
11. Analytics & Experimentation
Understanding user behavior and testing hypotheses for features being built.
11.1 Event Taxonomy
A structured list of events tracked in the app. Consistency in naming and parameters is key.
Core Events:
app_open: App launched from cold start or foregrounded after >30 mins.
screen_view:Â (screen_name: String)
user_signup:Â (method: 'email' | 'google' | 'apple')
Learning Loop Events:
lesson_start:Â (lesson_id: Int, band_id: Int, language_code: String)
lesson_complete:Â (lesson_id: Int, band_id: Int, duration_seconds: Int, errors_made: Int)
review_session_start:Â (card_count: Int)
review_session_complete:Â (cards_reviewed: Int, duration_seconds: Int, avg_ease_factor: Float)
card_reviewed:Â (card_id: Int, quality_response: Int, new_interval: Int)
boss_battle_start:Â (band_id: Int)
boss_battle_complete:Â (band_id: Int, score_pct: Int, passed: Bool, duration_seconds: Int)
Social & AI Events:
voice_note_submit:Â (context: 'self_study' | 'quick_game_audio', duration_seconds: Int)
ai_feedback_received:Â (context: 'self_study' | 'quick_game_audio' | 'live_teacher_session', processing_time_ms: Int)
quick_game_create:Â (language_code: String)
quick_game_turn_submit:Â (game_id: UUID, turn_number: Int)
quick_game_complete:Â (game_id: UUID, result: 'win' | 'loss' | 'draw', elo_change: Int)
Monetization & Live Session Events:
video_call_start:Â (type: 'teacher_session', room_id: UUID)Â (Note:Â typeÂ is now fixed)
video_call_complete:Â (type: 'teacher_session', duration_seconds: Int)Â (Note:Â typeÂ is now fixed)
teacher_slot_booked:Â (teacher_id: UUID, slot_id: UUID, price_usd: Decimal)
paywall_view:Â (source_trigger: String)
purchase_attempt:Â (product_id: String, price: Decimal)
purchase_success:Â (product_id: String, transaction_id: String)
purchase_fail:Â (product_id: String, error_code: String)
Serialization & Transport:
All events are structured as JSON objects.
Include common properties with every event:Â event_name,Â timestamp_utc,Â user_id,Â app_version,Â os_version,Â device_model,Â session_id.
POSTed batched toÂ TelemetryDeckÂ (a privacy-focused analytics service). TelemetryDeck client SDKs handle batching and sending.
11.2 A/B Framework
For controlled experimentation of features during development or phased rollout.
experimentsÂ Table (Supabase):
exp_id TEXT PRIMARY KEYÂ (e.g.,Â paywall_price_2025_q3)
name TEXT NOT NULLÂ (Human-readable name)
description TEXT
variants JSONB NOT NULLÂ (e.g.,Â {"control": {"weight": 50}, "variant_A": {"weight": 50, "config_key": "paywallPriceTierA"}, "variant_B": {"weight": 0, "config_key": "paywallPriceTierB"}})
config_keyÂ refers to a key inÂ remote_configÂ that holds the actual variant configuration.
rollout_pct INT DEFAULT 100 CHECK (rollout_pct >= 0 AND rollout_pct <= 100)Â (Percentage of eligible users included in this experiment).
is_active BOOLEAN DEFAULT TRUE
start_date TIMESTAMPTZ,Â end_date TIMESTAMPTZ
Client-Side Logic (SwiftÂ ExperimentGate):
Fetch Active Experiments:Â On app launch (or periodically), fetch allÂ experimentsÂ whereÂ is_active = TRUEand current date is withinÂ start_date/end_date.
User Bucketing:Â For each active experiment:
If user is part of theÂ rollout_pctÂ (e.g.,Â hash(user_id + exp_id) % 100 < rollout_pct).
Assign user to a variant based on weights (e.g.,Â hash(user_id + exp_id) % total_weight).
Store the assigned variant (e.g.,Â variant_A) locally for consistency for that user for the duration of the experiment (e.g., inÂ UserDefaultsÂ or a local DB).
Expose Variant Configuration:Â TheÂ ExperimentGateÂ helper provides functions likeÂ getPaywallConfig() -> PaywallConfig. Internally, it checks if the user is in an active paywall experiment, gets their assigned variant, and fetches the corresponding configuration fromÂ remote_configÂ via theÂ config_key. If not in an experiment or no variant assigned, it returns a default configuration.
Analytics:Â All tracked events (11.1) should also includeÂ experiment_idÂ andÂ variant_nameÂ properties if the user is part of an active experiment when the event occurs. This allows segmenting analytics data by experiment variant to measure impact of features under A/B test.
Change Log
v3.0 (May 19 2025)Â â€“ Rewritten into highâ€‘granularity master spec. Added exhaustive table definitions, UI accessibility notes, observability, quota enforcement, privacy compliance, A/B testing, and explicit OKRs.
v3.0.1 (Previous Enhanced Version)Â - Significantly expanded detail across all sections, providing more rationale, examples, deeper technical specifications for database tables, AI prompts, service logic, UI interactions, and operational considerations.
v3.0.2 (Current Focused Build Specification)Â - Refined scope: WebRTC video chat is now exclusively for 1-on-1 teacher lessons. Quick Games are asynchronous peer-to-peer audio-only duels. Removed post-build sections (Launch, OKRs) to focus strictly on the "what to build" specification. Updated relevant sections (Overview, UI, AI Pipelines, Real-Time Communication, Analytics) to reflect these changes.
